import{_ as a,c as e,o as t,a4 as r}from"./chunks/framework.CbHUKvme.js";const _=JSON.parse('{"title":"函数式编程","description":"","frontmatter":{"title":"函数式编程"},"headers":[],"relativePath":"summary/js/functional.md","filePath":"summary/js/functional.md","lastUpdated":1720441499000}'),o={name:"summary/js/functional.md"},i=r('<h1 id="函数式编程" tabindex="-1">函数式编程 <a class="header-anchor" href="#函数式编程" aria-label="Permalink to &quot;函数式编程&quot;">​</a></h1><h2 id="纯函数" tabindex="-1">纯函数 <a class="header-anchor" href="#纯函数" aria-label="Permalink to &quot;纯函数&quot;">​</a></h2><p>不会产生副作用，对于相同的参数每次执行结果都一样。例如 splice 和 slice 来说， splice 就不是纯函数， slice 是纯函数</p><h2 id="pipe" tabindex="-1">pipe <a class="header-anchor" href="#pipe" aria-label="Permalink to &quot;pipe&quot;">​</a></h2><p>返回一个函数，参数是多个函数。返回的函数被调用时，参数函数从左到右执行</p><h2 id="compose" tabindex="-1">compose <a class="header-anchor" href="#compose" aria-label="Permalink to &quot;compose&quot;">​</a></h2><p>返回一个函数，参数是多个函数。返回的函数被调用时，参数函数从右到左执行</p><h2 id="curry" tabindex="-1">curry <a class="header-anchor" href="#curry" aria-label="Permalink to &quot;curry&quot;">​</a></h2><p>只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数</p><h2 id="container-functor" tabindex="-1">container &amp; functor <a class="header-anchor" href="#container-functor" aria-label="Permalink to &quot;container &amp; functor&quot;">​</a></h2><p>产生一种对应的新数据结构，对数据封装，只能在容器内操作数据</p><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><a href="https://cheogo.github.io/learn-javascript/201710/functional.html" target="_blank" rel="noreferrer">JavaScript 函数式编程</a></li></ul>',13),n=[i];function c(l,s,h,p,u,d){return t(),e("div",null,n)}const f=a(o,[["render",c]]);export{_ as __pageData,f as default};
