import{_ as e,c as a,o,a4 as r}from"./chunks/framework.bPmW087-.js";const p=JSON.parse('{"title":"模块化","description":"","frontmatter":{"title":"模块化"},"headers":[],"relativePath":"summary/engineered/module.md","filePath":"summary/engineered/module.md","lastUpdated":1711331125000}'),t={name:"summary/engineered/module.md"},n=r('<h1 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h1><h2 id="commonjs" tabindex="-1">CommonJS <a class="header-anchor" href="#commonjs" aria-label="Permalink to &quot;CommonJS&quot;">​</a></h2><p>CommonJS 是社区规范，不是官方规范。所以它对应的 <strong>module</strong> 和 <strong>require</strong> 这些并不是关键字，只是一个对象或者函数。</p><h2 id="esm" tabindex="-1">ESM <a class="header-anchor" href="#esm" aria-label="Permalink to &quot;ESM&quot;">​</a></h2><p>ES Module</p><h2 id="commonjs-和-esm-的区别" tabindex="-1">CommonJS 和 ESM 的区别 <a class="header-anchor" href="#commonjs-和-esm-的区别" aria-label="Permalink to &quot;CommonJS 和 ESM 的区别&quot;">​</a></h2><ul><li>CommonJS 模块输出的是一个值的拷贝，ESM 模块输出的是值的引用</li><li>CommonJS 模块是运行时加载，ESM 模块是编译时输出接口</li><li>CommonJS 模块的 require() 是同步加载模块，ESM 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段</li><li>ESM 更好的支持 tree-shaking ，因为可以静态分析。就是 CommonJS 的 require 中可以写变量，无法做到静态分析</li></ul><h2 id="参考链接" tabindex="-1">参考链接 <a class="header-anchor" href="#参考链接" aria-label="Permalink to &quot;参考链接&quot;">​</a></h2><ul><li><p><a href="https://es6.ruanyifeng.com/#docs/module-loader" target="_blank" rel="noreferrer">Module 的加载实现</a></p></li><li><p><a href="https://juejin.cn/post/6844903576309858318" target="_blank" rel="noreferrer">前端模块化：CommonJS,AMD,CMD,ES6</a></p></li><li><p><a href="https://www.jianshu.com/p/850c139899f5" target="_blank" rel="noreferrer">浅谈前端模块化的发展历程</a></p></li></ul>',9),l=[n];function m(i,s,d,h,c,u){return o(),a("div",null,l)}const S=e(t,[["render",m]]);export{p as __pageData,S as default};
