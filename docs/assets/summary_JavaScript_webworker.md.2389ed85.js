import{_ as e,o as r,c as a,a as t}from"./app.8d8eadf5.js";const b=JSON.parse('{"title":"WebWorker","description":"","frontmatter":{"title":"WebWorker"},"headers":[{"level":2,"title":"WebWorker 线程数据通讯方式","slug":"webworker-线程数据通讯方式","link":"#webworker-线程数据通讯方式","children":[]},{"level":2,"title":"WebWorker 适合使用的场景","slug":"webworker-适合使用的场景","link":"#webworker-适合使用的场景","children":[]}],"relativePath":"summary/JavaScript/webworker.md","lastUpdated":1679221100000}'),o={name:"summary/JavaScript/webworker.md"},i=t('<h1 id="webworker" tabindex="-1">WebWorker <a class="header-anchor" href="#webworker" aria-hidden="true">#</a></h1><p>Javascript是运行在单线程环境中，也就是说无法同时运行多个脚本。假设用户点击一个按钮，触发了一段用于计算的Javascript代码，那么在这段代码执行完毕之前，页面是无法响应用户操作的。但是，如果将这段代码交给Web Worker去运行的话，那么情况就不一样了：浏览器会在后台启动一个独立的worker线程来专门负责这段代码的运行，因此，页面在这段Javascript代码运行期间依然可以响应用户的其他操作</p><h2 id="webworker-线程数据通讯方式" tabindex="-1">WebWorker 线程数据通讯方式 <a class="header-anchor" href="#webworker-线程数据通讯方式" aria-hidden="true">#</a></h2><p>Worker 与其主页面之间的通信是通过 onmessage 事件和 postMessage() 方法实现的</p><h2 id="webworker-适合使用的场景" tabindex="-1">WebWorker 适合使用的场景 <a class="header-anchor" href="#webworker-适合使用的场景" aria-hidden="true">#</a></h2><ul><li>加密数据</li><li>预取数据</li><li>预渲染</li><li>复杂数据处理场景</li><li>预加载图片</li></ul>',6),s=[i];function l(c,n,d,k,w,_){return r(),a("div",null,s)}const p=e(o,[["render",l]]);export{b as __pageData,p as default};
