import{_ as e,c as a,o as i,a as r}from"./app.c6564c1c.js";const _=JSON.parse('{"title":"隐藏的","description":"","frontmatter":{"title":"隐藏的"},"headers":[{"level":2,"title":"简历中所说的 cli 是什么","slug":"简历中所说的-cli-是什么","link":"#简历中所说的-cli-是什么","children":[]},{"level":2,"title":"简历中所说的 library 是什么","slug":"简历中所说的-library-是什么","link":"#简历中所说的-library-是什么","children":[]},{"level":2,"title":"简历中所说的 架构 是什么","slug":"简历中所说的-架构-是什么","link":"#简历中所说的-架构-是什么","children":[]},{"level":2,"title":"说说浏览器引擎","slug":"说说浏览器引擎","link":"#说说浏览器引擎","children":[]}],"relativePath":"interview/hidden.md","lastUpdated":1678114510000}'),t={name:"interview/hidden.md"},l=r('<h2 id="简历中所说的-cli-是什么" tabindex="-1">简历中所说的 cli 是什么 <a class="header-anchor" href="#简历中所说的-cli-是什么" aria-hidden="true">#</a></h2><details><summary><b>答案</b></summary><p><p>一个主站系统包含了很多业务模板。在开发中，每个业务模块就单独创建一个工程，也是一个单独的 Repo，单独管理和发布部署。集成到主站的方式就是打包成指定格式的 js, css 及其它静态资源。我们把这样一个工程叫做接入域。</p><p>而这个 cli 就是用来创建和管理这些接入域工程的，包含的功能有像 vue-cli，create-react-app 类似的创建接入域工程，更新接入域中的 sdk ， 批量运行工程（根据mainfest.xml） 根据代码中的 url 生成文件等。 整体来说就是完成一些重复的工作</p></p></details><h2 id="简历中所说的-library-是什么" tabindex="-1">简历中所说的 library 是什么 <a class="header-anchor" href="#简历中所说的-library-是什么" aria-hidden="true">#</a></h2><details><summary><b>答案</b></summary><p><p>一个主站系统包含了很多业务模板。在开发中，每个业务模块就单独创建一个工程，也是一个单独的 Repo，单独管理和发布部署。集成到主站的方式就是打包成指定格式的 js, css 及其它静态资源。我们把这样一个工程叫做接入域。</p><p>每个接入域要正常集成到主站中，要额外的做一些修改，比如修改路由注册的方式，以及有一些可能公用的模块或组件，library 就是这样的一个sdk。它还提供了一些基础依赖，比如 vue 。</p><p>这个 sdk 是 umd 格式的，其中包含一个立即执行函数，一但被引用就被调用。 这个函数的功能包括 mock 登录，注册路由等等。</p><p>而对应的引用方式是可以直接在 script 标签中引用 或者通过 commonjs 的 requireJs (这里原本想用 Vite 打包成 esm 的，但是由于 vite 打的包不能接入qiankun， 虽然后面出了一个插件但是没有再研究 )， 它将被定义成一个全局变量，然后不管是 webpack 还是 vite 都有额外的配置或插件可以使得在代码中可以向其它依赖包一样正常使用其中的工具或组件</p></p></details><h2 id="简历中所说的-架构-是什么" tabindex="-1">简历中所说的 架构 是什么 <a class="header-anchor" href="#简历中所说的-架构-是什么" aria-hidden="true">#</a></h2><details><summary><b>答案</b></summary><p><p>就是前面所说的 sdk , cli, 以及对应的使用文档，我是采用的 VitePress 搭建的 类似element-plus, antd 的源码，也是采用的 monorepo 的模式</p></p></details><h2 id="说说浏览器引擎" tabindex="-1">说说浏览器引擎 <a class="header-anchor" href="#说说浏览器引擎" aria-hidden="true">#</a></h2><details><summary><b>答案</b></summary><p><p>现在大家所说的浏览器内核通常是渲染引擎也叫排版引擎、解释引擎</p><p>内核负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果</p><p>v8 是由 c++ 编写， 而 JaegerMonkey 是由 c/c++ 混合编写的。 v8 的性能比 JaegerMonkey出色，而且异步非阻塞IO的V8性能优势非常大。它们的 GC 都是分代式回收，v8 引擎还有 hidden。 另外它们的 jit 编译有所不同， v8 抛弃了字节码。</p><p>blink 是现在谷歌浏览器以及欧朋浏览器使用的渲染引擎，而 blink 是基于 Webkit 开发的。并且谷歌在之前也是使用的 Webkit 引擎，并且 Webkit 最开始是由 苹果开发的。</p><p>blink 目前的区别：</p><ol><li><p>跨进程的 iframe(out-of-process iframes)：为 iframes 内容创建单独的沙箱进程来渲染它们</p></li><li><p>将 DOM 移入 JavaScript 中，这样 JavaScript 可以更快的访问 DOM</p></li></ol></p></details>',8),s=[l];function p(d,c,n,o,h,m){return i(),a("div",null,s)}const b=e(t,[["render",p]]);export{_ as __pageData,b as default};
