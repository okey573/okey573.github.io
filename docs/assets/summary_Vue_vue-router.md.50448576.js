import{_ as e,o as s,c as a,a as o}from"./app.2e7f410a.js";const m=JSON.parse('{"title":"vue-router","description":"","frontmatter":{"title":"vue-router"},"headers":[{"level":2,"title":"hash","slug":"hash","link":"#hash","children":[]},{"level":2,"title":"history","slug":"history","link":"#history","children":[]},{"level":2,"title":"memory","slug":"memory","link":"#memory","children":[]},{"level":2,"title":"传统的前端页面路由也分为三种：传统路由实现，Hash路由方式，H5 Router","slug":"传统的前端页面路由也分为三种-传统路由实现-hash路由方式-h5-router","link":"#传统的前端页面路由也分为三种-传统路由实现-hash路由方式-h5-router","children":[]}],"relativePath":"summary/Vue/vue-router.md","lastUpdated":1679193866000}'),l={name:"summary/Vue/vue-router.md"},t=o(`<p>这个路由是建立在spa的概念上的 路由分三个类型 hash, history, memory</p><h2 id="hash" tabindex="-1">hash <a class="header-anchor" href="#hash" aria-hidden="true">#</a></h2><p>hash模式在页面url上有个#号，是靠监听hash路由实现的</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addEventListener</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hashchange</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#676E95;font-style:italic;">/**...*/</span></span>
<span class="line"><span style="color:#89DDFF;">},</span><span style="color:#A6ACCD;"> </span><span style="color:#FF9CAC;">false</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div><h2 id="history" tabindex="-1">history <a class="header-anchor" href="#history" aria-hidden="true">#</a></h2><p>history模式是靠window.history的api实现的</p><ul><li><code>back()</code>后退到上一个路由；</li><li><code>forward()</code>前进到下一个路由，如果有的话；</li><li><code>go(number)</code>进入到任意一个路由，正数为前进，负数为后退；</li><li><code>pushState(obj, title, url)</code>前进到指定的 URL，不刷新页面；</li><li><code>replaceState(obj, title, url)</code>用 url 替换当前的路由，不刷新页面；</li></ul><p>调用这几种方式时，都会只是修改了当前页面的 URL，页面的内容没有任何的变化。但前 3 个方法只是路由历史记录的前进或者后退，无法跳转到指定的 URL；而pushState和replaceState可以跳转到指定的 URL。如果有面试官问起这个问题“如何仅修改页面的 URL，而不发送请求”，那么答案就是这 5 种方法。</p><h2 id="memory" tabindex="-1">memory <a class="header-anchor" href="#memory" aria-hidden="true">#</a></h2><p>memory模式适合非浏览器，或者SSR</p><p>hash和history都有一个共同点 把所有数据存在路径后面，不论是/1还是/#1，这里的东西一变，所有的东西都改变</p><p>memory不使用路径，使用localstorage。只对单机有效，页面没有链接 复制给别人只能进入初始状态</p><h2 id="传统的前端页面路由也分为三种-传统路由实现-hash路由方式-h5-router" tabindex="-1">传统的前端页面路由也分为三种：传统路由实现，Hash路由方式，H5 Router <a class="header-anchor" href="#传统的前端页面路由也分为三种-传统路由实现-hash路由方式-h5-router" aria-hidden="true">#</a></h2>`,13),r=[t];function n(p,h,i,c,d,u){return s(),a("div",null,r)}const _=e(l,[["render",n]]);export{m as __pageData,_ as default};
